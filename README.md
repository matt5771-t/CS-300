What was the problem you were solving in the projects for this course?
In Project One, I analyzed various data structures to evaluate their runtime efficiency and memory usage for different operations. In Project Two, I designed and implemented a program to manage course data using a BST, focusing on functionalities such as sorting and searching.

How did you approach the problem?
I began by identifying the requirements of each project and breaking them into smaller, manageable tasks. For Project One, I compared data structures like vectors, hash tables, and binary search trees, focusing on their strengths and weaknesses. For Project Two, I applied my understanding of BSTs to build a program capable of sorting courses efficiently and facilitating quick lookups.

How did you overcome any roadblocks you encountered?
When challenges arose, such as implementing BST traversal or debugging sorting functionality, I referred to course resources, pseudocode, and external programming guides. This iterative process of debugging and refinement ensured the final implementation met the requirements.

How has your work on this project expanded your approach to designing software and developing programs?
These projects reinforced the importance of selecting appropriate data structures based on specific needs. I learned to evaluate trade-offs, design modular code, and consider scalability and maintainability throughout the development process.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I now focus on:

Writing clear and modular code, making it easier to adapt and extend.

Using meaningful variable names and inline comments for better readability.

Applying industry-standard best practices for error handling and user input validation.
